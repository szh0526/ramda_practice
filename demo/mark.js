/**
 * 函数式编程 即通过管道把数据在一系列纯函数间传递的程序
 * DSL即声明式编程（声明式编程：定义要做什么,实现惰性求值 命令式编程：用一堆命令语句来描述怎么做）
 * JSX 也属于 DSL
 * 高阶函数：参数或返回值为函数的函数
 * ramda:自动柯里化和函数参数优先于数据
 * curry:柯里化是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数
 * ramda利用自动柯里化,是将另一个函数组合的先决条件。如常用的map操作需要接受两个参数，
    R.map(function(item){ return item *2; }, [2,3,5] ); //输出[4, 6, 10]
    var map = R.map(function(item){ return item *2; }); map([2,3,5]); //输出[4, 6, 10]
 *如果传2个完备的参数，则R.map直接执行。否则返回另一个函数，等参数完备时才执行。
  接受一个参数并返回一个新的函数,返回的函数就通过闭包的方式记住了父函数的第一个参数。

 UnderScore和lodash，要求先传入数据，后传转换函数。ramda则将数据参数最后一个传入，而转换函数和配置参数则优于数据参数，排在前面。
 可以在不触及数据的情况下，将一个函数算法子包装进另一个算法子中，实现两个独立转换功能的组合。
 通过管道把数据在接受单个参数的函数间传递。利用 curry，让函数先接收数据 -> 操作数据 -> 把数据传递到下一个函数
 */

//1.纯函数
let purefn = (a) => (b) => a(b);
//2.curry
let curryfn = (x) => (y) => x + y;



/*(a → a) → Number → [a] → [a]  
参数1:(a → a)函数  参数2:Number 参数3：[a]数组 返回值:[a]
(a → Boolean) → [a] → Boolean
参数1:(a → Boolean)函数传a参数返回Boolean  参数2:[a]数组 返回值Boolean
[(*… → Boolean)] → (*… → Boolean)
参数1：[(*… → Boolean)]数组包括一个返回Booleand的函数该函数参数为*...（多个不定类型参数）
返回值:(*… → Boolean)函数参数为多个不定类型参数返回Boolean
String → a → {k: v} → {k: v}
参数1:String类型的 参数2:a 参数3:{k: v}对象 返回值:{k: v}*/